## ADDED Requirements

### Requirement: Create Iced-rendered window
The system SHALL provide an API to create a Tauri window that renders Iced UI components using native GPU rendering.

#### Scenario: User creates Iced window with controls
- **WHEN** developer calls `app.create_iced_window("main", MyControls::new())?`
- **THEN** system creates a Tauri window with specified label
- **AND** system initializes Iced rendering backend with WGPU
- **AND** system attaches user's `IcedControls` implementation to the window

### Requirement: Define UI behavior via IcedControls trait
The system SHALL require users to implement the `IcedControls` trait to define their UI structure and state management.

#### Scenario: User implements IcedControls trait
- **WHEN** user implements `IcedControls` trait for their UI
- **THEN** user provides `view()` method returning Iced `Element`
- **AND** user provides `update()` method handling state changes
- **AND** user defines associated `Message` type for UI events

### Requirement: Convert Tauri events to Iced events
The system SHALL automatically convert Tauri window events to Iced-compatible events and feed them to the UI.

#### Scenario: Mouse move event processed
- **WHEN** user moves mouse cursor over Iced window
- **THEN** system converts Tauri mouse position to Iced cursor position
- **AND** system generates Iced `Event::PointerMoved`
- **AND** event is queued for processing

#### Scenario: Mouse click event processed
- **WHEN** user clicks mouse button over Iced window
- **THEN** system converts Tauri mouse button to Iced pointer button
- **AND** system generates Iced `Event::PointerButton` with pressed state
- **AND** event is queued for processing

#### Scenario: Keyboard input processed
- **WHEN** user presses keyboard key
- **THEN** system converts Tauri key event to Iced key event
- **AND** system tracks modifier keys (shift, ctrl, alt, cmd)
- **AND** event is queued for processing

#### Scenario: Window resize processed
- **WHEN** Tauri window is resized
- **THEN** system updates Iced viewport dimensions
- **AND** system resizes WGPU surface
- **AND** system requests redraw

### Requirement: Process UI messages synchronously
The system SHALL process UI messages generated by Iced in the same event loop iteration without async runtime.

#### Scenario: Button click triggers state update
- **WHEN** user clicks button in Iced UI
- **THEN** Iced generates a message for the button click
- **AND** system calls user's `update()` method with the message
- **AND** user's state is modified synchronously
- **AND** system requests redraw to reflect changes

### Requirement: Maintain independent window state
The system SHALL maintain independent state for each Iced window using a global hashmap keyed by window label.

#### Scenario: Multiple Iced windows have separate state
- **WHEN** developer creates two Iced windows with different labels
- **THEN** each window has its own `IcedControls` instance
- **AND** events are routed to the correct window's state
- **AND** rendering state is independent per window

### Requirement: Render Iced UI via headless renderer
The system SHALL use Iced's headless renderer to render UI into Tauri-created windows without owning the event loop.

#### Scenario: Render frame on redraw request
- **WHEN** system receives `RedrawRequested` event for Iced window
- **THEN** system builds UI from current controls state
- **THEN** system processes queued events
- **THEN** system draws UI to WGPU surface
- **AND** system presents frame to screen

### Requirement: Integrate with Tauri event loop
The system SHALL hook into Tauri's event loop using the `wry_plugin` mechanism.

#### Scenario: Plugin initialized with Tauri app
- **WHEN** developer calls `app.wry_plugin(Builder::new(app.handle().to_owned()))`
- **THEN** plugin registers with Tauri's event loop
- **AND** plugin can intercept window events
- **AND** plugin can request redraws

### Requirement: Support clipboard operations
The system SHALL provide clipboard integration to Iced's clipboard API.

#### Scenario: Clipboard passed to Iced
- **WHEN** system initializes Iced window
- **THEN** system creates Iced `Clipboard` instance
- **AND** clipboard is passed to `UserInterface::update()`
- **AND** Iced can read/write system clipboard

### Requirement: Update cursor based on UI state
The system SHALL change cursor icon based on Iced's mouse interaction state.

#### Scenario: Hover over interactive element changes cursor
- **WHEN** user hovers mouse over clickable element
- **THEN** Iced reports appropriate mouse interaction state
- **AND** system converts to Tauri cursor icon
- **AND** cursor is updated on window

### Requirement: Use thread-safe window management
The system SHALL use `Arc<Mutex<HashMap<String, IcedWindow>>>` to manage windows in a thread-safe manner.

#### Scenario: Concurrent access to window state
- **WHEN** event loop accesses window state
- **THEN** mutex lock is acquired
- **AND** window state can be safely modified
- **AND** lock is released after operation

### Requirement: Accept existing Tauri windows
The system SHALL accept an existing Tauri window and render Iced UI into it, rather than creating new windows.

#### Scenario: Iced attached to existing window
- **WHEN** developer creates Tauri window via `Window::builder()`
- **THEN** developer can call `create_iced_window()` with the window label
- **AND** plugin attaches Iced renderer to the existing window
- **AND** window remains Tauri-managed
